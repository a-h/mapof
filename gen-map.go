// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package mapof

import (
	"sort"
	"sync/atomic"
)

// StringToString creates a new map.
func StringToString() *StringToStringMap {
	return &StringToStringMap{
		mapKeysToIndex: make(map[string]*indexToStringWithValueString),
	}
}

// StringToStringMap is a map which retains the order of the keys.
type StringToStringMap struct {
	mapKeysToIndex map[string]*indexToStringWithValueString
	index          int64
}

// Add an item to the map.
func (m *StringToStringMap) Add(k string, v string) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToStringWithValueString{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *StringToStringMap) Get(k string) (v string, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *StringToStringMap) Del(k string) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *StringToStringMap) Keys() (keys []string) {
	kvs := make(indexToStringWithValueStrings, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]string, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToStringWithValueString struct {
	index int64
	key   string
	value string
}

type indexToStringWithValueStrings []indexToStringWithValueString

func (d indexToStringWithValueStrings) Len() int {
	return len(d)
}

func (d indexToStringWithValueStrings) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToStringWithValueStrings) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// StringToInt creates a new map.
func StringToInt() *StringToIntMap {
	return &StringToIntMap{
		mapKeysToIndex: make(map[string]*indexToStringWithValueInt),
	}
}

// StringToIntMap is a map which retains the order of the keys.
type StringToIntMap struct {
	mapKeysToIndex map[string]*indexToStringWithValueInt
	index          int64
}

// Add an item to the map.
func (m *StringToIntMap) Add(k string, v int) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToStringWithValueInt{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *StringToIntMap) Get(k string) (v int, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *StringToIntMap) Del(k string) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *StringToIntMap) Keys() (keys []string) {
	kvs := make(indexToStringWithValueInts, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]string, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToStringWithValueInt struct {
	index int64
	key   string
	value int
}

type indexToStringWithValueInts []indexToStringWithValueInt

func (d indexToStringWithValueInts) Len() int {
	return len(d)
}

func (d indexToStringWithValueInts) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToStringWithValueInts) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// StringToInt64 creates a new map.
func StringToInt64() *StringToInt64Map {
	return &StringToInt64Map{
		mapKeysToIndex: make(map[string]*indexToStringWithValueInt64),
	}
}

// StringToInt64Map is a map which retains the order of the keys.
type StringToInt64Map struct {
	mapKeysToIndex map[string]*indexToStringWithValueInt64
	index          int64
}

// Add an item to the map.
func (m *StringToInt64Map) Add(k string, v int64) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToStringWithValueInt64{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *StringToInt64Map) Get(k string) (v int64, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *StringToInt64Map) Del(k string) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *StringToInt64Map) Keys() (keys []string) {
	kvs := make(indexToStringWithValueInt64s, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]string, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToStringWithValueInt64 struct {
	index int64
	key   string
	value int64
}

type indexToStringWithValueInt64s []indexToStringWithValueInt64

func (d indexToStringWithValueInt64s) Len() int {
	return len(d)
}

func (d indexToStringWithValueInt64s) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToStringWithValueInt64s) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// IntToString creates a new map.
func IntToString() *IntToStringMap {
	return &IntToStringMap{
		mapKeysToIndex: make(map[int]*indexToIntWithValueString),
	}
}

// IntToStringMap is a map which retains the order of the keys.
type IntToStringMap struct {
	mapKeysToIndex map[int]*indexToIntWithValueString
	index          int64
}

// Add an item to the map.
func (m *IntToStringMap) Add(k int, v string) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToIntWithValueString{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *IntToStringMap) Get(k int) (v string, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *IntToStringMap) Del(k int) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *IntToStringMap) Keys() (keys []int) {
	kvs := make(indexToIntWithValueStrings, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]int, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToIntWithValueString struct {
	index int64
	key   int
	value string
}

type indexToIntWithValueStrings []indexToIntWithValueString

func (d indexToIntWithValueStrings) Len() int {
	return len(d)
}

func (d indexToIntWithValueStrings) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToIntWithValueStrings) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// IntToInt creates a new map.
func IntToInt() *IntToIntMap {
	return &IntToIntMap{
		mapKeysToIndex: make(map[int]*indexToIntWithValueInt),
	}
}

// IntToIntMap is a map which retains the order of the keys.
type IntToIntMap struct {
	mapKeysToIndex map[int]*indexToIntWithValueInt
	index          int64
}

// Add an item to the map.
func (m *IntToIntMap) Add(k int, v int) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToIntWithValueInt{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *IntToIntMap) Get(k int) (v int, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *IntToIntMap) Del(k int) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *IntToIntMap) Keys() (keys []int) {
	kvs := make(indexToIntWithValueInts, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]int, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToIntWithValueInt struct {
	index int64
	key   int
	value int
}

type indexToIntWithValueInts []indexToIntWithValueInt

func (d indexToIntWithValueInts) Len() int {
	return len(d)
}

func (d indexToIntWithValueInts) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToIntWithValueInts) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// IntToInt64 creates a new map.
func IntToInt64() *IntToInt64Map {
	return &IntToInt64Map{
		mapKeysToIndex: make(map[int]*indexToIntWithValueInt64),
	}
}

// IntToInt64Map is a map which retains the order of the keys.
type IntToInt64Map struct {
	mapKeysToIndex map[int]*indexToIntWithValueInt64
	index          int64
}

// Add an item to the map.
func (m *IntToInt64Map) Add(k int, v int64) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToIntWithValueInt64{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *IntToInt64Map) Get(k int) (v int64, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *IntToInt64Map) Del(k int) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *IntToInt64Map) Keys() (keys []int) {
	kvs := make(indexToIntWithValueInt64s, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]int, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToIntWithValueInt64 struct {
	index int64
	key   int
	value int64
}

type indexToIntWithValueInt64s []indexToIntWithValueInt64

func (d indexToIntWithValueInt64s) Len() int {
	return len(d)
}

func (d indexToIntWithValueInt64s) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToIntWithValueInt64s) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// Int64ToString creates a new map.
func Int64ToString() *Int64ToStringMap {
	return &Int64ToStringMap{
		mapKeysToIndex: make(map[int64]*indexToInt64WithValueString),
	}
}

// Int64ToStringMap is a map which retains the order of the keys.
type Int64ToStringMap struct {
	mapKeysToIndex map[int64]*indexToInt64WithValueString
	index          int64
}

// Add an item to the map.
func (m *Int64ToStringMap) Add(k int64, v string) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToInt64WithValueString{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *Int64ToStringMap) Get(k int64) (v string, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *Int64ToStringMap) Del(k int64) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *Int64ToStringMap) Keys() (keys []int64) {
	kvs := make(indexToInt64WithValueStrings, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]int64, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToInt64WithValueString struct {
	index int64
	key   int64
	value string
}

type indexToInt64WithValueStrings []indexToInt64WithValueString

func (d indexToInt64WithValueStrings) Len() int {
	return len(d)
}

func (d indexToInt64WithValueStrings) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToInt64WithValueStrings) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// Int64ToInt creates a new map.
func Int64ToInt() *Int64ToIntMap {
	return &Int64ToIntMap{
		mapKeysToIndex: make(map[int64]*indexToInt64WithValueInt),
	}
}

// Int64ToIntMap is a map which retains the order of the keys.
type Int64ToIntMap struct {
	mapKeysToIndex map[int64]*indexToInt64WithValueInt
	index          int64
}

// Add an item to the map.
func (m *Int64ToIntMap) Add(k int64, v int) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToInt64WithValueInt{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *Int64ToIntMap) Get(k int64) (v int, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *Int64ToIntMap) Del(k int64) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *Int64ToIntMap) Keys() (keys []int64) {
	kvs := make(indexToInt64WithValueInts, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]int64, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToInt64WithValueInt struct {
	index int64
	key   int64
	value int
}

type indexToInt64WithValueInts []indexToInt64WithValueInt

func (d indexToInt64WithValueInts) Len() int {
	return len(d)
}

func (d indexToInt64WithValueInts) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToInt64WithValueInts) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// Int64ToInt64 creates a new map.
func Int64ToInt64() *Int64ToInt64Map {
	return &Int64ToInt64Map{
		mapKeysToIndex: make(map[int64]*indexToInt64WithValueInt64),
	}
}

// Int64ToInt64Map is a map which retains the order of the keys.
type Int64ToInt64Map struct {
	mapKeysToIndex map[int64]*indexToInt64WithValueInt64
	index          int64
}

// Add an item to the map.
func (m *Int64ToInt64Map) Add(k int64, v int64) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToInt64WithValueInt64{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *Int64ToInt64Map) Get(k int64) (v int64, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *Int64ToInt64Map) Del(k int64) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *Int64ToInt64Map) Keys() (keys []int64) {
	kvs := make(indexToInt64WithValueInt64s, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]int64, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToInt64WithValueInt64 struct {
	index int64
	key   int64
	value int64
}

type indexToInt64WithValueInt64s []indexToInt64WithValueInt64

func (d indexToInt64WithValueInt64s) Len() int {
	return len(d)
}

func (d indexToInt64WithValueInt64s) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToInt64WithValueInt64s) Less(i, j int) bool {
	return d[i].index < d[j].index
}
