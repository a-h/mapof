// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package setof

import (
	"sort"
	"sync/atomic"
)

// NewStringToString creates a new map.
func NewStringToString() *StringToString {
	return &StringToString{
		mapKeysToIndex: make(map[string]*indexToStringWithValueString),
	}
}

// StringToString is a map which retains the order of the keys.
type StringToString struct {
	mapKeysToIndex map[string]*indexToStringWithValueString
	index          int64
}

// Add an item to the map.
func (m *StringToString) Add(k string, v string) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToStringWithValueString{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *StringToString) Get(k string) (v string, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *StringToString) Del(k string) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *StringToString) Keys() (keys []string) {
	kvs := make(indexToStringWithValueStrings, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]string, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToStringWithValueString struct {
	index int64
	key   string
	value string
}

type indexToStringWithValueStrings []indexToStringWithValueString

func (d indexToStringWithValueStrings) Len() int {
	return len(d)
}

func (d indexToStringWithValueStrings) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToStringWithValueStrings) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// NewStringToInt creates a new map.
func NewStringToInt() *StringToInt {
	return &StringToInt{
		mapKeysToIndex: make(map[string]*indexToStringWithValueInt),
	}
}

// StringToInt is a map which retains the order of the keys.
type StringToInt struct {
	mapKeysToIndex map[string]*indexToStringWithValueInt
	index          int64
}

// Add an item to the map.
func (m *StringToInt) Add(k string, v int) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToStringWithValueInt{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *StringToInt) Get(k string) (v int, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *StringToInt) Del(k string) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *StringToInt) Keys() (keys []string) {
	kvs := make(indexToStringWithValueInts, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]string, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToStringWithValueInt struct {
	index int64
	key   string
	value int
}

type indexToStringWithValueInts []indexToStringWithValueInt

func (d indexToStringWithValueInts) Len() int {
	return len(d)
}

func (d indexToStringWithValueInts) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToStringWithValueInts) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// NewStringToInt64 creates a new map.
func NewStringToInt64() *StringToInt64 {
	return &StringToInt64{
		mapKeysToIndex: make(map[string]*indexToStringWithValueInt64),
	}
}

// StringToInt64 is a map which retains the order of the keys.
type StringToInt64 struct {
	mapKeysToIndex map[string]*indexToStringWithValueInt64
	index          int64
}

// Add an item to the map.
func (m *StringToInt64) Add(k string, v int64) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToStringWithValueInt64{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *StringToInt64) Get(k string) (v int64, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *StringToInt64) Del(k string) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *StringToInt64) Keys() (keys []string) {
	kvs := make(indexToStringWithValueInt64s, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]string, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToStringWithValueInt64 struct {
	index int64
	key   string
	value int64
}

type indexToStringWithValueInt64s []indexToStringWithValueInt64

func (d indexToStringWithValueInt64s) Len() int {
	return len(d)
}

func (d indexToStringWithValueInt64s) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToStringWithValueInt64s) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// NewIntToString creates a new map.
func NewIntToString() *IntToString {
	return &IntToString{
		mapKeysToIndex: make(map[int]*indexToIntWithValueString),
	}
}

// IntToString is a map which retains the order of the keys.
type IntToString struct {
	mapKeysToIndex map[int]*indexToIntWithValueString
	index          int64
}

// Add an item to the map.
func (m *IntToString) Add(k int, v string) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToIntWithValueString{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *IntToString) Get(k int) (v string, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *IntToString) Del(k int) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *IntToString) Keys() (keys []int) {
	kvs := make(indexToIntWithValueStrings, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]int, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToIntWithValueString struct {
	index int64
	key   int
	value string
}

type indexToIntWithValueStrings []indexToIntWithValueString

func (d indexToIntWithValueStrings) Len() int {
	return len(d)
}

func (d indexToIntWithValueStrings) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToIntWithValueStrings) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// NewIntToInt creates a new map.
func NewIntToInt() *IntToInt {
	return &IntToInt{
		mapKeysToIndex: make(map[int]*indexToIntWithValueInt),
	}
}

// IntToInt is a map which retains the order of the keys.
type IntToInt struct {
	mapKeysToIndex map[int]*indexToIntWithValueInt
	index          int64
}

// Add an item to the map.
func (m *IntToInt) Add(k int, v int) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToIntWithValueInt{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *IntToInt) Get(k int) (v int, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *IntToInt) Del(k int) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *IntToInt) Keys() (keys []int) {
	kvs := make(indexToIntWithValueInts, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]int, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToIntWithValueInt struct {
	index int64
	key   int
	value int
}

type indexToIntWithValueInts []indexToIntWithValueInt

func (d indexToIntWithValueInts) Len() int {
	return len(d)
}

func (d indexToIntWithValueInts) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToIntWithValueInts) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// NewIntToInt64 creates a new map.
func NewIntToInt64() *IntToInt64 {
	return &IntToInt64{
		mapKeysToIndex: make(map[int]*indexToIntWithValueInt64),
	}
}

// IntToInt64 is a map which retains the order of the keys.
type IntToInt64 struct {
	mapKeysToIndex map[int]*indexToIntWithValueInt64
	index          int64
}

// Add an item to the map.
func (m *IntToInt64) Add(k int, v int64) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToIntWithValueInt64{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *IntToInt64) Get(k int) (v int64, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *IntToInt64) Del(k int) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *IntToInt64) Keys() (keys []int) {
	kvs := make(indexToIntWithValueInt64s, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]int, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToIntWithValueInt64 struct {
	index int64
	key   int
	value int64
}

type indexToIntWithValueInt64s []indexToIntWithValueInt64

func (d indexToIntWithValueInt64s) Len() int {
	return len(d)
}

func (d indexToIntWithValueInt64s) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToIntWithValueInt64s) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// NewInt64ToString creates a new map.
func NewInt64ToString() *Int64ToString {
	return &Int64ToString{
		mapKeysToIndex: make(map[int64]*indexToInt64WithValueString),
	}
}

// Int64ToString is a map which retains the order of the keys.
type Int64ToString struct {
	mapKeysToIndex map[int64]*indexToInt64WithValueString
	index          int64
}

// Add an item to the map.
func (m *Int64ToString) Add(k int64, v string) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToInt64WithValueString{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *Int64ToString) Get(k int64) (v string, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *Int64ToString) Del(k int64) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *Int64ToString) Keys() (keys []int64) {
	kvs := make(indexToInt64WithValueStrings, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]int64, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToInt64WithValueString struct {
	index int64
	key   int64
	value string
}

type indexToInt64WithValueStrings []indexToInt64WithValueString

func (d indexToInt64WithValueStrings) Len() int {
	return len(d)
}

func (d indexToInt64WithValueStrings) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToInt64WithValueStrings) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// NewInt64ToInt creates a new map.
func NewInt64ToInt() *Int64ToInt {
	return &Int64ToInt{
		mapKeysToIndex: make(map[int64]*indexToInt64WithValueInt),
	}
}

// Int64ToInt is a map which retains the order of the keys.
type Int64ToInt struct {
	mapKeysToIndex map[int64]*indexToInt64WithValueInt
	index          int64
}

// Add an item to the map.
func (m *Int64ToInt) Add(k int64, v int) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToInt64WithValueInt{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *Int64ToInt) Get(k int64) (v int, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *Int64ToInt) Del(k int64) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *Int64ToInt) Keys() (keys []int64) {
	kvs := make(indexToInt64WithValueInts, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]int64, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToInt64WithValueInt struct {
	index int64
	key   int64
	value int
}

type indexToInt64WithValueInts []indexToInt64WithValueInt

func (d indexToInt64WithValueInts) Len() int {
	return len(d)
}

func (d indexToInt64WithValueInts) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToInt64WithValueInts) Less(i, j int) bool {
	return d[i].index < d[j].index
}

// NewInt64ToInt64 creates a new map.
func NewInt64ToInt64() *Int64ToInt64 {
	return &Int64ToInt64{
		mapKeysToIndex: make(map[int64]*indexToInt64WithValueInt64),
	}
}

// Int64ToInt64 is a map which retains the order of the keys.
type Int64ToInt64 struct {
	mapKeysToIndex map[int64]*indexToInt64WithValueInt64
	index          int64
}

// Add an item to the map.
func (m *Int64ToInt64) Add(k int64, v int64) {
	if kv, ok := m.mapKeysToIndex[k]; ok {
		kv.value = v
		return
	}
	m.mapKeysToIndex[k] = &indexToInt64WithValueInt64{
		index: atomic.AddInt64(&m.index, 1),
		key:   k,
		value: v,
	}
}

// Get an item from the map.
func (m *Int64ToInt64) Get(k int64) (v int64, ok bool) {
	kv, ok := m.mapKeysToIndex[k]
	v = kv.value
	return
}

// Del deletes an item from the map.
func (m *Int64ToInt64) Del(k int64) {
	delete(m.mapKeysToIndex, k)
}

// Keys returns all of the keys within the map.
func (m *Int64ToInt64) Keys() (keys []int64) {
	kvs := make(indexToInt64WithValueInt64s, len(m.mapKeysToIndex))
	var index int
	for _, kv := range m.mapKeysToIndex {
		kvs[index] = *kv
		index++
	}
	sort.Sort(kvs)
	keys = make([]int64, len(m.mapKeysToIndex))
	for i, v := range kvs {
		keys[i] = v.key
	}
	return keys
}

type indexToInt64WithValueInt64 struct {
	index int64
	key   int64
	value int64
}

type indexToInt64WithValueInt64s []indexToInt64WithValueInt64

func (d indexToInt64WithValueInt64s) Len() int {
	return len(d)
}

func (d indexToInt64WithValueInt64s) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d indexToInt64WithValueInt64s) Less(i, j int) bool {
	return d[i].index < d[j].index
}
